# GitLab CI/CD Pipeline for GKE Deployment with Testing and Security
# This pipeline runs tests, performs security scanning, builds a Docker image, and deploys to GKE

# Define the stages of your pipeline
stages:
  - test      # Run automated tests
  - security  # Security scanning
  - build     # Build the Docker image
  - deploy    # Deploy to GKE

# Global variables
variables:
  PROJECT_ID: "deron-innovations"
  REGION: "us-central1"
  REPO: "ai-powered-pdf-table-extractor-repo" # name of the repo in the artifact registry
  REGISTRY: "us-central1-docker.pkg.dev" # registry url
  CLUSTER: "ai-powered-pdf-table-extractor-cluster" # name of the cluster in the gke
  IMAGE_NAME: $REGISTRY/$PROJECT_ID/$REPO/ai-powered-pdf-table-extractor

# Test Stage: Run pytest tests
test:
  stage: test
  image: python:3.11-slim
  before_script:
    # Install package with dev dependencies from pyproject.toml
    - pip install --quiet -e ".[dev]"
  script:
    # Run pytest with coverage reporting
    # -v: verbose output, --tb=short: shorter traceback format
    - pytest -v --tb=short --cov=src --cov-report=term --cov-report=html
  # Extract test coverage percentage from pytest output for GitLab's coverage badge
  # This regex looks for lines like "TOTAL ... 85%" and extracts the percentage
  # GitLab will display this as a coverage badge in the UI (e.g., "coverage: 85%")
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
      - .coverage
    expire_in: 1 week
    when: always
  only:
    - main
    - master
    - merge_requests  # Also run on merge requests
  allow_failure: false  # Pipeline fails if tests fail

# Security Stage: Scan dependencies for vulnerabilities
security:dependency-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    # Install security scanning tools
    - pip install --quiet pip-audit safety
    - pip install --quiet -e ".[dev]"
  script:
    # Scan dependencies for known vulnerabilities using pip-audit
    - echo "Running pip-audit for dependency vulnerability scanning..."
    - pip-audit --desc --skip-editable || true
    # Also run safety check as a backup
    - echo "Running safety check..."
    - safety check --json || true
  only:
    - main
    - master
    - merge_requests
  allow_failure: true  # Don't block pipeline, but report issues

# Security Stage: Scan Python code for security issues
security:code-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    # Install bandit for security code analysis
    - pip install --quiet bandit[toml]
  script:
    # Scan Python code for common security issues
    - echo "Running bandit security scanner..."
    - bandit -r src/ app.py -f json -o bandit-report.json || true
    - bandit -r src/ app.py -ll  # Show medium and high severity issues
  artifacts:
    reports:
      # GitLab can parse this for security dashboard
      sast: bandit-report.json
    paths:
      - bandit-report.json
    expire_in: 1 week
    when: always
  only:
    - main
    - master
    - merge_requests
  allow_failure: true  # Don't block pipeline, but report issues

# Security Stage: Scan for exposed secrets
security:secret-scan:
  stage: security
  image: python:3.11-slim
  before_script:
    # Install gitleaks for secret scanning
    - apt-get update && apt-get install -y wget
    - wget -q https://github.com/gitleaks/gitleaks/releases/download/v8.18.1/gitleaks_8.18.1_linux_x64.tar.gz
    - tar -xzf gitleaks_8.18.1_linux_x64.tar.gz
    - chmod +x gitleaks
  script:
    # Scan for secrets and credentials in code
    - echo "Scanning for exposed secrets..."
    - ./gitleaks detect --source . --verbose --no-git || true
  only:
    - main
    - master
    - merge_requests
  allow_failure: true  # Don't block pipeline, but report issues

# Build Stage: Create Docker image and push to Google Artifact Registry
build_docker_image:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - apk add --no-cache python3 curl bash
    - curl https://sdk.cloud.google.com | bash -s -- --disable-prompts > /dev/null
    - export PATH=$PATH:/root/google-cloud-sdk/bin
    - echo "$GCP_SERVICE_KEY" | base64 -d > gcp-key.json
    - gcloud auth activate-service-account --key-file=gcp-key.json
    - gcloud auth configure-docker $REGISTRY
  script:
    # Build the Docker image with commit SHA tag and latest tag
    - docker build -t $IMAGE_NAME:$CI_COMMIT_SHORT_SHA .
    - docker tag $IMAGE_NAME:$CI_COMMIT_SHORT_SHA $IMAGE_NAME:latest
    # Push both tags to Google Artifact Registry
    - docker push $IMAGE_NAME:$CI_COMMIT_SHORT_SHA
    - docker push $IMAGE_NAME:latest
  only:
    - main  # Only build on main branch
    - master  # Also support master branch name
  needs: ["test"]  # Wait for tests to pass before building

# Security Stage: Scan Docker image for vulnerabilities
security:container-scan:
  stage: deploy  # Run as part of deploy stage but before actual deployment
  image: google/cloud-sdk:alpine
  before_script:
    # Authenticate with Google Cloud to pull the image
    - echo "$GCP_SERVICE_KEY" | base64 -d > ${HOME}/gcp-key.json
    - gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
    - gcloud config set project $PROJECT_ID
    - gcloud auth configure-docker $REGISTRY --quiet
    # Install trivy
    - apk add --no-cache wget tar
    - wget -q https://github.com/aquasecurity/trivy/releases/download/v0.48.3/trivy_0.48.3_Linux-64bit.tar.gz
    - tar -xzf trivy_0.48.3_Linux-64bit.tar.gz
    - mv trivy /usr/local/bin/
    - chmod +x /usr/local/bin/trivy
  script:
    # Scan the Docker image for vulnerabilities
    - echo "Scanning Docker image for vulnerabilities..."
    - trivy image --severity HIGH,CRITICAL --format json --output trivy-report.json $IMAGE_NAME:$CI_COMMIT_SHORT_SHA || true
    - trivy image --severity HIGH,CRITICAL $IMAGE_NAME:$CI_COMMIT_SHORT_SHA || true
  artifacts:
    reports:
      container_scanning: trivy-report.json
    paths:
      - trivy-report.json
    expire_in: 1 week
    when: always
  only:
    - main
    - master
  allow_failure: true  # Don't block deployment, but report issues
  needs: ["build_docker_image"]  # Wait for build to complete

# Deploy Stage: Deploy the Docker image to GKE
deploy_to_gke:
  stage: deploy
  image: google/cloud-sdk:latest
  needs:
    - build_docker_image
    - security:container-scan
  before_script:
    - echo "$GCP_SERVICE_KEY" | base64 -d > gcp-key.json
    - gcloud auth activate-service-account --key-file=gcp-key.json
    - gcloud config set project $PROJECT_ID
  script:
    # Get GKE cluster credentials
    - gcloud container clusters get-credentials $CLUSTER --region $REGION --project $PROJECT_ID
    # Update the image tag in the deployment and apply
    - kubectl set image deployment/ai-powered-pdf-table-extractor ai-powered-pdf-table-extractor=$IMAGE_NAME:$CI_COMMIT_SHORT_SHA --record || kubectl apply -f kubernetes-deployment.yaml
    # Verify deployment
    - kubectl rollout status deployment/ai-powered-pdf-table-extractor
  only:
    - main
    - master
  when: on_success  # Only deploy if all previous stages succeed
